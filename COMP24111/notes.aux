\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\providecommand \oddpage@label [2]{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Machine Learning}{3}{section.1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Nearest Neighbour Classifier}{3}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Finding the distance between two $n$-dimensional points}{3}{subsection.2.1}}
\newlabel{scala_nn}{{1}{3}{Scala Euclidean Distance}{lstlisting.1}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1}Scala Euclidean Distance}{3}{lstlisting.1}}
\gincltex@bb{diagrams/knn-large.tex}{0}{0}{172.46927}{61.92828}
\gincltex@bb{diagrams/knn-boundary.tex}{0}{0}{44.2132}{58.38638}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Computing the nearest neighbour}{4}{subsection.2.2}}
\newlabel{nearestNeighbour}{{2}{4}{Scala Nearest Neighbour}{lstlisting.2}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {2}Scala Nearest Neighbour}{4}{lstlisting.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Multiple nearest neighbours (K-NN)}{4}{subsection.2.3}}
\newlabel{nearestNeighbour}{{3}{4}{Scala Nearest Neighbour}{lstlisting.3}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {3}Scala Nearest Neighbour}{4}{lstlisting.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces How K affects classification accuracy. The item being classified is the filled square and nearest neighbours are filled, and other elements are left unfilled. When K=3, it would be classified as square, when K=5, it'd be classified as a circle.\relax }}{4}{figure.caption.5}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{fig:knn-large}{{1}{4}{How K affects classification accuracy. The item being classified is the filled square and nearest neighbours are filled, and other elements are left unfilled. When K=3, it would be classified as square, when K=5, it'd be classified as a circle.\relax }{figure.caption.5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Overfitting}{4}{subsection.2.4}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces The dotted line represents the decision boundary for a KNN classifier\relax }}{5}{figure.caption.6}}
\newlabel{fig:knn-boundary}{{2}{5}{The dotted line represents the decision boundary for a KNN classifier\relax }{figure.caption.6}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Linear Classifier}{5}{section.3}}
\newlabel{linearClassifier}{{4}{5}{A simple linear classifier}{lstlisting.4}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {4}A simple linear classifier}{5}{lstlisting.4}}
\newlabel{linearClassifierLearningAlgorithm}{{5}{5}{Linear classifier learning algorithm}{lstlisting.5}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {5}Linear classifier learning algorithm}{5}{lstlisting.5}}
\gincltex@bb{diagrams/generic-ML-algorithm.tex}{0}{0}{182.15457}{112.2218}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces A generic ML algorithm always has the above structure.\relax }}{6}{figure.caption.7}}
\newlabel{fig:generic-ML-algorithm}{{3}{6}{A generic ML algorithm always has the above structure.\relax }{figure.caption.7}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Perceptron}{6}{section.4}}
\newlabel{perceptron}{{6}{6}{A perceptron implementation in MATLAB}{lstlisting.6}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {6}A perceptron implementation in MATLAB}{6}{lstlisting.6}}
\newlabel{perceptronTraining}{{7}{7}{A perceptron learning algorithm in Java}{lstlisting.7}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7}A perceptron learning algorithm in Java}{7}{lstlisting.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Multilayer Perceptrons (MLP)}{7}{subsection.4.1}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Decision trees}{8}{section.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}Building a decision tree}{8}{subsection.5.1}}
\newlabel{createDecisionTree}{{8}{8}{An algorithm (the ID3 algorithm) to produce a decision tree in Java}{lstlisting.8}{}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {8}An algorithm (the ID3 algorithm) to produce a decision tree in Java}{8}{lstlisting.8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {5.1.1}Entropy}{8}{subsubsection.5.1.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2}Overfitting decision trees}{10}{subsection.5.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces The vertical line shows the cutoff point, where the error rate for testing with the validation data (red, unbroken) begins to rise, while the error rate for the training data (blue, dashed), which we're generating the decision tree from, is still improving. It is here that we should prune the tree.\relax }}{10}{figure.caption.9}}
\newlabel{fig:overfitting}{{4}{10}{The vertical line shows the cutoff point, where the error rate for testing with the validation data (red, unbroken) begins to rise, while the error rate for the training data (blue, dashed), which we're generating the decision tree from, is still improving. It is here that we should prune the tree.\relax }{figure.caption.9}{}}
